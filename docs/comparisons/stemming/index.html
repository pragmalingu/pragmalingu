<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.ff31de0ff">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="PragmaLingu Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="PragmaLingu Blog Atom Feed"><title data-react-helmet="true">Simple Search vs. Stemming | PragmaLingu</title><meta data-react-helmet="true" property="og:url" content="https://www.pragmalingu.de/docs/comparisons/stemming"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Simple Search vs. Stemming | PragmaLingu"><meta data-react-helmet="true" name="description" content="A Comparison of different stemming approaches in Elasticsearch"><meta data-react-helmet="true" property="og:description" content="A Comparison of different stemming approaches in Elasticsearch"><meta data-react-helmet="true" name="keywords" content="stemming,hunspell stemmer,algorithmic stemming,Elasticsearch"><link data-react-helmet="true" rel="shortcut icon" href="/img/kleines_Icon_1.png"><link data-react-helmet="true" rel="canonical" href="https://www.pragmalingu.de/docs/comparisons/stemming"><link data-react-helmet="true" rel="alternate" href="https://www.pragmalingu.de/docs/comparisons/stemming" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://www.pragmalingu.de/docs/comparisons/stemming" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.0ccf2777.css">
<link rel="preload" href="/assets/js/runtime~main.ae02cbab.js" as="script">
<link rel="preload" href="/assets/js/main.b3afd3f8.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/kleines_Icon_2.webp" alt="Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/kleines_Icon_2.webp" alt="Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title"></strong></a><a class="navbar__item navbar__link" href="/docs/comparisons/comparisons-intro">Comparisons</a><a class="navbar__item navbar__link" href="/docs/experiments/experiments-intro">Experiments</a><a class="navbar__item navbar__link" href="/docs/guides/guides-intro">Guides</a><a class="navbar__item navbar__link" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/docs/about/team">About</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/pragmalingu" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/kleines_Icon_2.webp" alt="Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/kleines_Icon_2.webp" alt="Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title"></strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/comparisons/comparisons-intro">Comparisons</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/experiments/experiments-intro">Experiments</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/guides/guides-intro">Guides</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/about/team">About</a></li><li class="menu__list-item"><a href="https://github.com/pragmalingu" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/comparisons/comparisons-intro">Introduction</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" href="/docs/comparisons/stemming">Stemming</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/comparisons/german-decomposition">Decomposition</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/comparisons/embeddings">Embeddings</a></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">Simple Search vs. Stemming</h1></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1-what-is-stemming"></a>1. What is Stemming?<a class="hash-link" href="#1-what-is-stemming" title="Direct link to heading">#</a></h2><p>Stemming is the process of removing the alternating endings from words. Words with the same meaning, but different endings can then be matched better.  For example, The words <strong>fish</strong>, <strong>fishing</strong>, and <strong>fished</strong> would all be reduced to their common word stem <strong>fish</strong>. For the usage in a search engine, this stem is then stored in the <a href="https://en.wikipedia.org/wiki/Search_engine_indexing#Inverted_indices" target="_blank" rel="noopener noreferrer">inverted index</a> instead of the original word at that position.
When you search with any of the original words, your query is also stemmed and the search engine can find all documents that contain words with the same stem. This way, more relevant documents are found since the search query does not only rely on the given word forms but also matches the same word with different endings.</p><p>There are two common approaches to implement stemming in search engines.  </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="algorithmic-stemming"></a>Algorithmic Stemming<a class="hash-link" href="#algorithmic-stemming" title="Direct link to heading">#</a></h3><p>The <a href="https://snowballstem.org/algorithms/porter/stemmer.html" target="_blank" rel="noopener noreferrer">Porter stemming algorithm</a>, created by <a href="https://en.wikipedia.org/wiki/Martin_Porter" target="_blank" rel="noopener noreferrer">Martin Porter</a>, is one of the most popular algorithmic stemmers and is used by default in the built-in <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/analysis-stemmer-tokenfilter.html" target="_blank" rel="noopener noreferrer">language analyzers</a> in Elasticsearch.
Algorithmic stemmers are very fast and do not require a lot of memory as they only apply a set of rules that represents the common rules on how words are <a href="https://en.wikipedia.org/wiki/Inflection" target="_blank" rel="noopener noreferrer">inflected</a> in a specific language.<br>
Because there are always exceptions in natural language, an algorithmic stemmer might produce the same stem for words that have different meanings.
This error is called <a href="https://en.wikipedia.org/wiki/Stemming#Error_metrics" target="_blank" rel="noopener noreferrer"><strong>overstemming</strong></a>.
Another error that can happen is called <a href="https://en.wikipedia.org/wiki/Stemming#Error_metrics" target="_blank" rel="noopener noreferrer"><strong>understemming</strong></a> and happens when two inflected words with different endings but the same meaning and stem are not reduced to the same stem.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dictionary-based-stemming"></a>Dictionary Based Stemming<a class="hash-link" href="#dictionary-based-stemming" title="Direct link to heading">#</a></h3><p>The second approach to stemming is <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/stemming.html#dictionary-stemmers" target="_blank" rel="noopener noreferrer">dictionary-based stemming</a>.
Dictionary stemmers look up words in a dictionary before they remove their inflected endings and reduce them to their stem. This approach should work better on irregular words or words that are similar but have different meanings. Dictionary stemmers should be able to reduce over- and understemming and achieve better results than algorithmic stemmers. In practice, they sometimes perform worse than algorithmic stemmers because freely available dictionaries are never complete and are often missing important words or are outdated. Dictionary stemmers also have the drawback that they are slower and require more memory as they have to look up all the words in their dictionary.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="comparison"></a>Comparison<a class="hash-link" href="#comparison" title="Direct link to heading">#</a></h3><p>In this comparison we will answer the following questions:</p><ul><li>How much does the relevancy of search results improve by using a stemmer?</li><li>How well does the Hunspell stemmer that is included in Elasticsearch perform with a free dictionary?</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2-results"></a>2. Results<a class="hash-link" href="#2-results" title="Direct link to heading">#</a></h2><p>The following results are from our <a href="/docs/experiments/experiment1">First Experiment</a>. You can reproduce these results yourself if you follow the instructions in our <a href="/docs/experiments/experiments-intro">experiment section</a>.
We calculated <a href="https://en.wikipedia.org/wiki/Precision_and_recall" target="_blank" rel="noopener noreferrer">Precision and Recall</a> at k=20 for several datasets and show the resulting F1-score. </p><p><strong>F1-Score</strong></p><details><summary>What is an &quot;F1-Score&quot;?</summary><p>The F1-Score measures a harmonic mean between <a href="https://en.wikipedia.org/wiki/Precision_and_recall" target="_blank" rel="noopener noreferrer">Precision and Recall</a>. Therefore, we multiply Precision and Recall by two and divide it by the sum of Precision and Recall:<br>
<code>F1-Score=(2*Precision*Recall)/(Precision+Recall)</code><br>
This is the simplest way to balance both Precision and Recall, there are also other common options to weight them differently.</p></details><img alt="F1-Score" src="/img/EXP1_FScore.svg"><a href="https://colab.research.google.com/github/pragmalingu/experiments/blob/master/01_Stemming/Evaluation/Comparison_Stemming_vs_Standard_Search.ipynb#scrollTo=F_WKHLDXJypJ" target="_blank" rel="noopener noreferrer" class="buttons"><button class="buttons">Reproduce it in Google Colab</button></a><br><br><p>On all evaluation datasets except NPL, the Algorithmic Stemmer outperformed the Standard Analyzer as well as the Hunspell Token Filter.
The achieved F1-Score gains - measured in percentage points - with the Standard Analyzer as the baseline can be seen here:</p><img alt="F1-Score Gains" src="/img/EXP1_Gains.svg"><br><br><p>Depending on the use-case, algorithmic stemming can create up to a <strong>22% improvement</strong> in the relevance of the search results. Hunspell stemming performs worse than algorithmic stemming on nearly all datasets and can even lead to worse results than no stemming.</p><p>The average F1-Score gains across all datasets are:</p><img alt="F1-Score Gains" src="/img/EXP1_Average.svg"><p>Using the Stemmer Token Filter on English documents can therefore improve the F1-Score by an average of 11%.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3-discussion"></a>3. Discussion<a class="hash-link" href="#3-discussion" title="Direct link to heading">#</a></h2><p>Looking at the F1-Score from our approaches we can see that both stemming approaches perform better than the standard baseline on most of the datasets. The Algorithmic Stemmer performs better than the Standard Analyzer with the largest gains on the CACM and NPL corpora. The Hunspell Stemmer performs worse than the Algorithmic Stemmer on most of the datasets except the NPL dataset, where it performs slightly better. On the Medline corpus, the Hunspell Stemmer performs even worse than the Standard Analyzer.</p><p>There are several interesting questions that we can ask based on these results:</p><ol><li>Why does the Algorithmic Stemmer perform better than the Standard Analyzer?</li><li>Why does the Algorithmic Stemmer perform better than the Hunspell Stemmer?</li><li>Why does the Hunspell Stemmer perform worse than the Standard Analyzer on the Medline dataset?</li><li>Why does the Hunspell Stemmer perform better than the Algorithmic Stemmer on the NPL dataset?</li></ol><p>We will try to answer these questions by breaking down the results of the individual query and word matches.<br>
You can follow all steps in detail and reproduce the results by running our <a href="https://colab.research.google.com/github/pragmalingu/experiments/blob/master/01_Stemming/Evaluation/Comparison_Stemming_vs_Standard_Search.ipynb#scrollTo=X33-_O4rPMso" target="_blank" rel="noopener noreferrer">comparison notebook</a>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="31-algorithmic-stemmer-improvements-over-the-standard-analyzer"></a>3.1 Algorithmic Stemmer improvements over the Standard Analyzer<a class="hash-link" href="#31-algorithmic-stemmer-improvements-over-the-standard-analyzer" title="Direct link to heading">#</a></h3><p>We can see from the gains that the Algorithmic Stemmer performs better than the Standard Analyzer on all tested datasets.
But how does the Algorithmic Stemmer achieve these results?</p><p>We can answer this by looking at the NPL dataset which shows a significant gain of <strong>19.65%</strong> for the Stemmer Token Filter over the Standard Analyzer.</p><p>We first used our search analysis tool to figure out the queries that demonstrate <a href="https://colab.research.google.com/github/pragmalingu/experiments/blob/master/01_Stemming/Evaluation/Comparison_Stemming_vs_Standard_Search.ipynb#scrollTo=_fC_-pb7G4HM" target="_blank" rel="noopener noreferrer">the largest F1-Score improvements</a> with the Stemmer Token Filter.
The three queries with the biggest F1-Score difference are <strong>62</strong>, <strong>73</strong>, and <strong>52</strong>. We will be looking at query <strong>62</strong>.</p><p>The query text of query 63 is:  </p><blockquote><p>FAST TRANSISTOR COUNTERS.</p></blockquote><p>We first looked at the disjoint true positives sets of the query results for both the Algorithmic Stemmer and the Standard Analyzer.
The highest-ranked document for the Algorithmic Stemmer that is not present in the top <strong>k=20</strong> results of the Standard Analyzer is <a href="https://colab.research.google.com/github/pragmalingu/experiments/blob/master/01_Stemming/Evaluation/Comparison_Stemming_vs_Standard_Search.ipynb#scrollTo=QjP7C2guRRhm" target="_blank" rel="noopener noreferrer">document <code>8341</code></a>. For the Standard Analyzer, this document <a href="https://colab.research.google.com/github/pragmalingu/experiments/blob/master/01_Stemming/Evaluation/Comparison_Stemming_vs_Standard_Search.ipynb#scrollTo=1JMpo-U2SWEW" target="_blank" rel="noopener noreferrer">appears at position 34</a> which is outside the <strong>k=20</strong> result set that we used to calculate precision and recall.</p><p>The text of the relevant document is: </p><blockquote><p>nonsaturating pulse circuits using two junction transistors junction transistors are found to be fast enough for pulse applications if the collector voltage is
prevented from reaching zero switching times can be achieved with available types the required limiting action is effected by introducing diodes which terminate
the switching transients by their breakdown a two transistor binary counter is described</p></blockquote><p>For the <strong>Algorithmic Stemmer</strong> the document is at position <strong>3</strong> and returns the following highlighted text:</p><blockquote><p>nonsaturating pulse circuits using two junction <strong>transistors</strong>  junction <strong>transistors</strong> are found to be <strong>fast</strong> (...)  a two <strong>transistor</strong> binary <strong>counter</strong> is described</p></blockquote><p>The overall document score of <strong>12.49</strong> is the sum of these individual term scores:</p><table><thead><tr><th>Term</th><th>Score</th><th>Term Frequency</th><th>Document Frequency</th></tr></thead><tbody><tr><td>fast</td><td>4.31</td><td>1</td><td>84</td></tr><tr><td>transistor</td><td>4.22</td><td>3</td><td>640</td></tr><tr><td>counter</td><td>3.95</td><td>1</td><td>127</td></tr></tbody></table><p>For the <strong>Standard Analyzer</strong> the same document is at position <strong>34</strong> and returns the following highlighted text:</p><blockquote><p>nonsaturating pulse circuits using two junction transistors  junction transistors are found to be <strong>fast</strong> is effected by introducing diodes which terminate the switching transients by their breakdown  a two <strong>transistor</strong></p></blockquote><p>The overall document score of <strong>7.10</strong> is the sum of these individual term scores:</p><table><thead><tr><th>Term</th><th>Score</th><th>Term Frequency</th><th>Document Frequency</th></tr></thead><tbody><tr><td>fast</td><td>4.31</td><td>1</td><td>84</td></tr><tr><td>transistor</td><td>2.78</td><td>1</td><td>479</td></tr></tbody></table><p>We can see that for the Standard Analyzer the inflected word <strong>counters</strong> is not matched with the word <strong>counter</strong> in the document. The occurrences of the word <strong>transistors</strong> are also not matched with the stem <strong>transistor</strong> used in the query and, therefore, the term frequency and score of the word are lower.
The document frequency is also lower, which normally leads to a higher score, but cannot make up for the lower term frequency in this instance.</p><img alt="NPL: matched terms in document 8342 for query 62" src="/img/EXP1_Query_62_explain.svg"><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="32-hunspell-stemmer-improvements-over-the-algorithmic-stemmer"></a>3.2 Hunspell Stemmer improvements over the Algorithmic Stemmer:<a class="hash-link" href="#32-hunspell-stemmer-improvements-over-the-algorithmic-stemmer" title="Direct link to heading">#</a></h3><p>The NPL dataset is also the only dataset where our Hunspell Token Filter performed slightly better than the Algorithmic Stemmer. We can use our search analysis tool again to extract relevant examples from the datasets that show how the <a href="https://colab.research.google.com/github/pragmalingu/experiments/blob/master/01_Stemming/Evaluation/Comparison_Stemming_vs_Standard_Search.ipynb#scrollTo=dkAJ64J3UnC_" target="_blank" rel="noopener noreferrer">Hunspell Stemmer achieves better results</a>.</p><p>We again started by calculating the F1-Score differences for all queries between the Hunspell stemmer and the Algorithmic Stemmer.
Likewise, we picked the query that showed the biggest F1-Score difference favoring the Hunspell Stemmer, which is query <code>80</code>.</p><p>The query text of query 80 is: </p><blockquote><p>COULD YOU PLEASE GIVE ME ARTICLES ABOUT THE POSSIBILITIES OF GETTING RECTIFICATION USING METALLIC DEVICES.</p></blockquote><p>If we look at the disjoint set of true positives, we can see that the Hunspell Stemmer finds document <code>8094</code> at position <code>1</code>, while the Algorithmic Stemmer ranks this document at position <code>130</code>.</p><p>The text of document <code>8094</code> is:</p><blockquote><p>component design trends metallic rectifiers approach infinite life developments in cu se si ge and rectifiers are surveyed new designs give reduced size and longer life together with higher operating temperature output current and reverse voltage ratings</p></blockquote><p>As we can see, there are some strange tokens in the text: <code>cu se si ge</code>. We double-checked the original files of the dataset to ensure that it is actually in the files and not an artifact of our processing.</p><p>The Hunspell Stemmer returns the following highlighted text:</p><blockquote><p>component design trends <strong>metallic</strong> <strong>rectifiers</strong> approach infinite life developments in cu se si ge and <strong>rectifiers</strong> are surveyed new designs <strong>give</strong> reduced size and longer life together with higher operating temperature&#x27;</p></blockquote><p>The overall document score with the Hunspell Stemmer of <strong>16.61</strong> is the sum of these individual term scores:</p><table><thead><tr><th>Term</th><th>Score</th><th>Term Frequency</th><th>Document Frequency</th></tr></thead><tbody><tr><td>g or give</td><td>4.74</td><td>2</td><td>426</td></tr><tr><td>rectification or  rectify</td><td>5.98</td><td>2</td><td>180</td></tr><tr><td>metallic</td><td>5.88</td><td>1</td><td>47</td></tr></tbody></table><p>The Algorithmic Stemmer on the other hand returns the following highlighted text:</p><blockquote><p>component design trends <strong>metallic</strong> rectifiers approach infinite life developments in cu se si ge and rectifiers are surveyed new designs <strong>give</strong> reduced size and longer life together with higher operating temperature</p></blockquote><p>The overall document score with the algorithmic stemmer of <strong>7.27</strong> is the sum of these individual term scores:</p><table><thead><tr><th>Term</th><th>Score</th><th>Term Frequency</th><th>Document Frequency</th></tr></thead><tbody><tr><td>give</td><td>3.45</td><td>1</td><td>426</td></tr><tr><td>metal</td><td>3.82</td><td>1</td><td>300</td></tr></tbody></table><img alt="Matched Terms in document 8094 for query 80" src="/img/EXP1_Query_80_explain.svg"><p>These results show us that the Algorithmic Stemmer is missing the hit on the search term <strong>RECTIFICATION</strong> which appears in the document as <strong>rectifiers</strong>.
We also see that the keyword <strong>metallic</strong> receives a better (lower) document frequency with the Hunspell Stemmer because it is not stemmed to <strong>metal</strong>.</p><p>Why doesn&#x27;t the Algorithmic Stemmer match <strong>rectification</strong> with <strong>rectifiers</strong>? We can use the Analyze API endpoint of Elasticsearch to see how the Algorithmic Stemmer handles these words:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">POST /pragmalingu-stemming-npl-corpus/_analyze</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;text&quot;: &quot;rectification rectifiers rectify&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Response:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;tokens&quot; : [</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;token&quot; : &quot;rectif&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;start_offset&quot; : 0,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;end_offset&quot; : 13,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;position&quot; : 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;token&quot; : &quot;rectifi&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;start_offset&quot; : 14,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;end_offset&quot; : 24,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;position&quot; : 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;token&quot; : &quot;rectifi&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;start_offset&quot; : 25,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;end_offset&quot; : 32,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;position&quot; : 2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Here we can see that <strong>rectification</strong> gets overstemmed to <strong>rectif</strong> instead of <strong>rectifi</strong> and is, therefore, not matched with the other tokens.</p><p>But how exactly does the Hunspell Stemmer manage to match this keyword?
We can also look at the output of the Analyze API endpoint to answer this question:</p><p>Request:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">POST /pragmalingu-hunspell-npl-corpus/_analyze</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;text&quot;: &quot;rectification rectifiers rectify&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Response:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;tokens&quot; : [</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;token&quot; : &quot;rectification&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;start_offset&quot; : 0,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;end_offset&quot; : 13,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;position&quot; : 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;token&quot; : &quot;rectify&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;start_offset&quot; : 0,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;end_offset&quot; : 13,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;position&quot; : 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;token&quot; : &quot;rectify&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;start_offset&quot; : 14,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;end_offset&quot; : 24,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;position&quot; : 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;token&quot; : &quot;rectify&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;start_offset&quot; : 25,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;end_offset&quot; : 32,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;position&quot; : 2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>How does the Hunspell stemmer find the keyword &quot;rectifiers&quot;?</p><p>We can see that the search term <strong>rectification</strong> gets expanded to the following <a href="https://lucene.apache.org/core/8_8_2/core/org/apache/lucene/search/SynonymQuery.html" target="_blank" rel="noopener noreferrer">synonym query</a>: <code>Synonym(text:rectification text:rectify)</code>.
This means that Elasticsearch is looking up both terms at the same position, combining their term frequency, and using the highest document frequency for the score.
<strong>Rectify</strong> seems to be the stem that the Hunspell Token Filter found in <a href="https://cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic" target="_blank" rel="noopener noreferrer">its dictionary</a> for the word <strong>rectification</strong> and also <strong>rectifiers</strong>. If we look at the <a href="https://cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic" target="_blank" rel="noopener noreferrer">Hunspell dictionary</a> we find the following entry: <code>rectify/XNDRSZG</code>,
To understand these letters, we can look at the corresponding <a href="https://cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff" target="_blank" rel="noopener noreferrer">suffix rules</a> that enable the Hunspell stemmer to match these words.</p><p>The first relevant rule here is <strong>N</strong>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">SFX N Y 3  </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">SFX N e ion e  </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">SFX N y ication y  </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">SFX N 0 en [^ey]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>There is a good explanation of how these Hunspell dictionaries and affix files work and what the individual columns in the rules mean on the <a href="https://www.chromium.org/developers/how-tos/editing-the-spell-checking-dictionaries#TOC-Full-details" target="_blank" rel="noopener noreferrer">Chromium developer documentation site</a>.</p><p>The third line <code>SFX N y ication y</code> enables the matching of rectification.</p><p>But in the text <strong>rectifiers</strong> are mentioned and not <strong>rectify</strong>, so we need an additional rule during indexing that matches <strong>rectifiers</strong> to the stem <strong>rectify</strong>.</p><p>The rule <strong>Z</strong> has a matching line for that:  </p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">SFX Z Y 4  </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">SFX Z 0 rs e  </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">SFX Z y iers \[^aeiou\]y  </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">SFX Z 0 ers \[aeiou\]y  </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">SFX Z 0 ers \[^ey\]  </span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Here, the third line <code>SFX Z y iers [^aeiou]y</code> would match the word <strong>rectifiers</strong> and thus enable the token filter to replace it with the base entry in the dictionary.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="33-algorithmic-stemmer-improvements-over-the-hunspell-stemmer"></a>3.3 Algorithmic Stemmer improvements over the Hunspell Stemmer:<a class="hash-link" href="#33-algorithmic-stemmer-improvements-over-the-hunspell-stemmer" title="Direct link to heading">#</a></h3><p>In most cases, the Algorithmic Stemmer outperforms the Hunspell Stemmer.
To find examples that explain this performance, we looked at the CACM and ADI datasets, as they showed the most significant differences.</p><p>First, we looked at the CACM dataset to find good examples. We calculated the F1-Score differences for both approaches with our <a href="https://search-analysis.readthedocs.io/en/latest/" target="_blank" rel="noopener noreferrer">search analysis tool</a> and picked query <strong>26</strong> because it exhibits the greatest F1-Score difference between the two approaches.  </p><p>The query text of query 26 is:</p><blockquote><p>Concurrency control mechanisms in operating systems  </p></blockquote><p>The first document in the disjoint set of true positives that is not found by the Hunspell Stemmer is document <code>1198</code>.</p><p>The text and the title of the document are:<br>
<em>Title:</em></p><blockquote><p>Solution of a Problem in Concurrent Programming Control  </p></blockquote><p><em>Text:</em></p><blockquote><p>A number of mainly independent sequential-cyclic processes with restricted means of communication  with each other can be made in such a way that at any moment one and only one of them is engaged in the  &quot;critical section&quot; of its cycle. </p></blockquote><p>The document appears at position <code>3</code> for the Algorithmic Stemmer and at position <code>50</code> for the Hunspell Stemmer.</p><p>The Algorithmic Stemmer returns the following highlighted text:</p><blockquote><p>independent sequential-cyclic processes with restricted means of communication  with each other can be made <strong>in</strong> such a way that at any moment one and only one of them is engaged <strong>in</strong> the  &quot;critical section&quot; of its
And the following highlighted title:
&#x27;Solution of a Problem <strong>in</strong> <strong>Concurrent</strong> Programming <strong>Control</strong>&#x27;</p></blockquote><p>The overall document score with the Algorithmic Stemmer of <strong>12.06</strong> is the sum of the term scores in the <strong>title</strong> field:</p><table><thead><tr><th>Term</th><th>Field</th><th>Score</th><th>Term Frequency</th><th>Document Frequency</th></tr></thead><tbody><tr><td>in</td><td>text</td><td>0.40</td><td>2</td><td>1236</td></tr><tr><td>concurr</td><td>title</td><td>5.77</td><td>1</td><td>8</td></tr><tr><td>control</td><td>title</td><td>4.30</td><td>1</td><td>38</td></tr><tr><td>in</td><td>title</td><td>1.98</td><td>1</td><td>416</td></tr></tbody></table><p>Only the matches in the title field are counted for the overall document score.
This happens because we are using the default scoring strategy for the multi-match query that is <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html#multi-match-types" target="_blank" rel="noopener noreferrer"><strong>best_field</strong></a>, which takes the highest score of one of the searched fields as the document&#x27;s overall score.</p><p>The Hunspell Stemmer, on the other hand, returns the following highlighted text:  </p><blockquote><p>independent sequential-cyclic processes with restricted means of communication with each other can be made <strong>in</strong> such a way that at any moment one and only one of them is engaged <strong>in</strong> the &quot;critical section&quot; of its<br>
And the following highlighted title:
Solution of a Problem <strong>in</strong> Concurrent Programming <strong>Control</strong>  </p></blockquote><p>The overall document score with the Hunspell Stemmer of <strong>6.66</strong> is also the sum of the term scores in the <strong>title</strong> field:</p><table><thead><tr><th>Term</th><th>Field</th><th>Score</th><th>Term Frequency</th><th>Document Frequency</th></tr></thead><tbody><tr><td>in</td><td>text</td><td>0.41</td><td>2</td><td>1236</td></tr><tr><td>control</td><td>title</td><td>4.62</td><td>1</td><td>31</td></tr><tr><td>in</td><td>title</td><td>2.04</td><td>1</td><td>416</td></tr></tbody></table><img alt="CACM matched terms in document 1198 for query 26" src="/img/CACM matched terms in document 1198 for query 26.svg"><p>The Hunspell Stemmer could not match the important keyword <strong>Concurrency</strong> with <strong>Concurrent</strong> in the document title.
We can look at the output of the Analyze API endpoint of Elasticsearch to see how the Hunspell Stemmer handles these two words:
Request:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">POST /pragmalingu-hunspell-cacm-corpus/_analyze</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;text&quot;: &quot;concurrency concurrent&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Response:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &quot;tokens&quot; : [</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;token&quot; : &quot;concurrency&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;start_offset&quot; : 0,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;end_offset&quot; : 11,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;position&quot; : 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;token&quot; : &quot;current&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;start_offset&quot; : 12,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;end_offset&quot; : 22,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;position&quot; : 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>We can see that <strong>concurrency</strong> is not stemmed and <strong>concurrent</strong> seems to be overstemmed to <strong>current</strong>. We can look at the Hunspell dictionary and the affix file to see which rules lead to this outcome:  </p><p>For <strong>concurrency</strong> there is exactly one entry: <code>concurrency</code><br>
For <code>concurrent</code> we find the following rule that seems to explain the overstemming to the term <strong>current</strong>.<br>
<code>current/FAY</code><br>
The rules <strong>FAY</strong> in the affix file are:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">PFX A Y 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">PFX A   0     re         .</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">PFX F Y 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">PFX F   0     con        .</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">SFX Y Y 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">SFX Y   0     ly         .</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>This means that the words <strong>current</strong>, <strong>recurrent</strong>, <strong>concurrent</strong>, and <strong>currently</strong> are all stemmed to <strong>current</strong>.</p><p>This seems to indicate that the Hunspell dictionaries we are using, which are freely available for spell-checking, are not optimized for this stemmer use case.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="34-standard-analyzer-improvements-over-the-hunspell-stemmer"></a>3.4 Standard Analyzer improvements over the Hunspell Stemmer:<a class="hash-link" href="#34-standard-analyzer-improvements-over-the-hunspell-stemmer" title="Direct link to heading">#</a></h3><p>On the Medline dataset, the Hunspell Stemmer performed worse than the default Standard Analyzer. We are again looking at the biggest <a href="https://colab.research.google.com/github/pragmalingu/experiments/blob/master/01_Stemming/Evaluation/Comparison_Stemming_vs_Standard_Search.ipynb#scrollTo=KLDIRhISQnls&amp;line=2&amp;uniqifier=1" target="_blank" rel="noopener noreferrer">F1-Score difference</a> favoring the Standard Analyzer to find examples that explain the poor performance of the Hunspell Stemmer.</p><p>Query 1 exhibits the biggest F1-Score difference between the Standard Analyzer and the Hunspell Stemmer.</p><p>The query text of query 1 is:</p><blockquote><p>the crystalline lens in vertebrates, including humans.  </p></blockquote><p>The first document in the disjoint true positive set of query 1 is document <code>170</code>.
The text of document 170 is:</p><blockquote><p>identification of species-specific and organ-specific antigens in lens proteins.
the species-specific and organ-specific antigens of lens were investigated by gel diffusion and immunoelectrophoresis techniques.
it  was found that rabbit antiserum to bovine lens showed cross reaction with other bovine tissues.
these cross-reacting antigens were the b- -  and y-crystallins .
there were two major and a minor organ-specific antigen in lens .
both the major antigens had a mobility and were        identified as the a-crystallin of lens .</p></blockquote><p>The Standard Analyzer returns this document at position 9 with the following highlighted matched keywords:</p><blockquote><p>identification of species-specific and organ-specific antigens <strong>in</strong> <strong>lens</strong> proteins.
<strong>the</strong> species-specific and organ-specific antigens of <strong>lens</strong> were investigated by gel diffusion reaction with other bovine tissues.
these cross-reacting antigens were <strong>the</strong> b- -  and y-crystallins there were two major and a minor organ-specific
antigen <strong>in</strong> <strong>lens</strong> . both <strong>the</strong> major antigens had a mobility and were identified as <strong>the</strong> a-crystallin of <strong>lens</strong>.</p></blockquote><p>The overall document score with the Standard Analyzer was <strong>6.22</strong> and was the sum of the following term scores: </p><table><thead><tr><th>Term</th><th>Score</th><th>Term Frequency</th><th>Document Frequency</th></tr></thead><tbody><tr><td>the</td><td>0.022</td><td>4</td><td>2020</td></tr><tr><td>lens</td><td>6.13</td><td>5</td><td>41</td></tr><tr><td>in</td><td>0.07</td><td>2</td><td>987</td></tr></tbody></table><p>The Hunspell Stemmer instead positioned the document <code>170</code> at position 25 for query 1 and returned the following highlighted text:</p><blockquote><p>Identification of species-specific and organ-specific antigens <strong>in</strong> <strong>lens</strong> proteins.
<strong>The</strong> species-specific and organ-specific antigens of <strong>lens</strong> were investigated by gel diffusion and immunoelectrophoresis techniques.
It was found that rabbit antiserum to bovine <strong>lens</strong> showed cross reaction with other bovine organ-specific
antigen <strong>in</strong> lens.Both <strong>the</strong> major antigens had a mobility and were identified as <strong>the</strong> a-crystallin of <strong>lens</strong>.</p></blockquote><p>The overall document score with the Hunspell Stemmer was <strong>5.378082</strong> which is slightly lower than the Standard Analyzer score:</p><table><thead><tr><th>Term</th><th>Score</th><th>Term Frequency</th><th>Document Frequency</th></tr></thead><tbody><tr><td>the</td><td>0.026</td><td>4</td><td>1018</td></tr><tr><td>l or lens</td><td>5.27</td><td>8</td><td>75</td></tr><tr><td>in</td><td>0.07</td><td>2</td><td>986</td></tr></tbody></table><img alt="Medline, matched terms in document 170 for query 1.svg" src="/img/Medline, matched terms in document 170 for query 1.svg"><p>We can see that nearly all the score differences come from the different weighting of the hits for the term <strong>lens</strong>.
The Hunspell Stemmer searches both with the original term <strong>lens</strong> and with the letter <strong>l</strong>.
This seems to come from the Hunspell dictionary that contains the following entry:  </p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">l/SDXTGJ  </span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>This entry is combined with the suffix rule X:  </p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">SFX X Y 3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">SFX X   e     ions       e</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">SFX X   y     ications   y</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">SFX X   0     ens        [^ey]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Where the fourth line <code>SFX X   0     ens        [^ey]</code> leads to a match with the word <em>lens</em>.
Together, they lead to the dictionary entry <strong>l</strong> and the entry <code>lens/MS</code> matching.
The term <strong>l</strong> has a higher document frequency of <strong>75</strong> than the term <strong>lens</strong> where the document frequency is <strong>41</strong>.
Elasticsearch creates a synonym query for both terms and picks the highest document frequency for the scoring when these terms match.</p><p>This is another indication that the freely available LibreOffice dictionaries that we are using for the Hunspell Token Filter are not optimized for the stemming use-case.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="4-conclusion"></a>4. Conclusion<a class="hash-link" href="#4-conclusion" title="Direct link to heading">#</a></h2><p>For all our tested datasets, algorithmic stemming showed considerable increases in the F1-Score gains, ranging from 1.4% - 21.9%. As algorithmic stemming is built into the language analyzers provided by Elasticsearch, it is fairly easy to use. Due to its rule-based nature, it does not come with considerable processing or memory overhead.</p><p>Dictionary-based stemming, as provided by the Hunspell Token Filter, is not especially easy to use since you need a good dictionary that is tailored to the stemming tasks.
The analysis in our discussion section indicated that the freely available Hunspell dictionaries that we used from the LibreOffice project are not really suitable for stemming.
Hunspell dictionary stemming improved over the Standard Analyzer in all but one dataset, but it could not beat the Algorithmic Stemmer with the dictionaries we tested.</p><p>The overall conclusions and recommendations from our experiment are:</p><ul><li>To get a quick and cheap boost in relevancy for your search use-case, use the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html" target="_blank" rel="noopener noreferrer">Language Analyzers provided by Elasticsearch</a>.</li><li>Only consider the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-hunspell-tokenfilter.html" target="_blank" rel="noopener noreferrer">Hunspell Token Filter</a> if you have access to a good dictionary and are sure that it will improve relevancy for your use-case.</li><li>Don&#x27;t choose the Hunspell Token Filter with the freely available LibreOffice dictionaries over the algorithmic stemmers.  </li></ul><br><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="acknowledgements"></a>Acknowledgements:<a class="hash-link" href="#acknowledgements" title="Direct link to heading">#</a></h4><p>Thanks to Kenny Hall and Miriam Rupprecht for proofreading this article.</p><div class="col text--right"><em><small>Written by <strong>Samy Ateia</strong>,  Mai 2021</small></em></div></div></article><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/comparisons/comparisons-intro"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Let&#x27;s compare!</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/comparisons/german-decomposition"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">German Decomposition Â»</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-what-is-stemming" class="table-of-contents__link">1. What is Stemming?</a><ul><li><a href="#algorithmic-stemming" class="table-of-contents__link">Algorithmic Stemming</a></li><li><a href="#dictionary-based-stemming" class="table-of-contents__link">Dictionary Based Stemming</a></li><li><a href="#comparison" class="table-of-contents__link">Comparison</a></li></ul></li><li><a href="#2-results" class="table-of-contents__link">2. Results</a></li><li><a href="#3-discussion" class="table-of-contents__link">3. Discussion</a><ul><li><a href="#31-algorithmic-stemmer-improvements-over-the-standard-analyzer" class="table-of-contents__link">3.1 Algorithmic Stemmer improvements over the Standard Analyzer</a></li><li><a href="#32-hunspell-stemmer-improvements-over-the-algorithmic-stemmer" class="table-of-contents__link">3.2 Hunspell Stemmer improvements over the Algorithmic Stemmer:</a></li><li><a href="#33-algorithmic-stemmer-improvements-over-the-hunspell-stemmer" class="table-of-contents__link">3.3 Algorithmic Stemmer improvements over the Hunspell Stemmer:</a></li><li><a href="#34-standard-analyzer-improvements-over-the-hunspell-stemmer" class="table-of-contents__link">3.4 Standard Analyzer improvements over the Hunspell Stemmer:</a></li></ul></li><li><a href="#4-conclusion" class="table-of-contents__link">4. Conclusion</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Content</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/comparisons/comparisons-intro">Comparisons</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/experiments/experiments-intro">Experiments</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/guides/guides-intro">Guides</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/pragmalingu" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://discord.gg/uzXWeKQ" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="http://eepurl.com/heTv2X" target="_blank" rel="noopener noreferrer" class="footer__link-item">Newsletter</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/pragmalingu" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/about/team">About</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/impressum">Impressum</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2021 PragmaLingu</div></div></div></footer></div>
<script src="/assets/js/runtime~main.ae02cbab.js"></script>
<script src="/assets/js/main.b3afd3f8.js"></script>
</body>
</html>